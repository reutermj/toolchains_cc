#!/bin/bash
set -euox pipefail
source ${SCRIPTS_DIR}/environment

export PATH=${BUILD_TOOLS}/bin:$PATH

GCC_BUILD="/tmp/gcc-build"
mkdir -p ${GCC_BUILD}
cd ${GCC_BUILD}

CONFIGURE_FLAGS=()

# The bootstrap vendor in --build forces GCC's cross-compilation install layout for all targets.
# See: docs/lore/gcc/native_vs_cross_install_layout.md
if [[ "${BOOTSTRAP}" == "true" ]]; then
    CONFIGURE_FLAGS+=(--build=${BUILD_ARCH}-linux-gnu)
    CONFIGURE_FLAGS+=(--host=${BUILD_ARCH}-linux-gnu)
    CONFIGURE_FLAGS+=(--target=${TARGET})
else
    CONFIGURE_FLAGS+=(--build=${BUILD_ARCH}-bootstrap-linux-gnu)
    CONFIGURE_FLAGS+=(--host=${BUILD_ARCH}-bootstrap-linux-gnu)
    CONFIGURE_FLAGS+=(--target=${TARGET})
fi

# The --with-sysroot flag enables sysroot support in GCC, allowing users to pass --sysroot=<path>
# at compile time to redirect all header/library searches to a different root directory. This is
# essential for cross-compilation and hermetic builds where target libraries live in a separate
# directory tree (e.g., a Bazel repo rule).
#
# The value passed here (${BUILD_TOOLS}) serves two purposes:
# 1. Sets the default sysroot for this build (we need Linux headers from BUILD_TOOLS to compile libgcc)
# 2. More importantly, compiles sysroot support into GCC itself - without this flag, the deployed
#    toolchain won't accept --sysroot at runtime
#
# When deployed, users can override with: gcc --sysroot=/their/path/to/target/libs
CONFIGURE_FLAGS+=(--with-sysroot=${BUILD_TOOLS})
CONFIGURE_FLAGS+=(--with-local-prefix=${BUILD_TOOLS})

# GCC dependency libraries built in earlier steps
CONFIGURE_FLAGS+=(--with-gmp=${BUILD_TOOLS})
CONFIGURE_FLAGS+=(--with-mpfr=${BUILD_TOOLS})
CONFIGURE_FLAGS+=(--with-mpc=${BUILD_TOOLS})
CONFIGURE_FLAGS+=(--with-isl=${BUILD_TOOLS})

# Installation prefix for packaging
CONFIGURE_FLAGS+=(--prefix=${GCC_ARTIFACTS})
CONFIGURE_FLAGS+=(--exec_prefix=${GCC_ARTIFACTS})

# Disable unnecessary GCC runtime libraries
CONFIGURE_FLAGS+=(--disable-libgomp)
CONFIGURE_FLAGS+=(--disable-libmudflap)
CONFIGURE_FLAGS+=(--disable-libmpx)
CONFIGURE_FLAGS+=(--disable-libssp)
CONFIGURE_FLAGS+=(--disable-libquadmath)
CONFIGURE_FLAGS+=(--disable-libquadmath-support)

# Additional build configuration
CONFIGURE_FLAGS+=(--disable-plugin)
CONFIGURE_FLAGS+=(--disable-nls)
CONFIGURE_FLAGS+=(--disable-multilib)

# C++ runtime support (needed even for C-only compiler building C code that uses C++)
CONFIGURE_FLAGS+=(--enable-__cxa_atexit)

# Optimization flags
CONFIGURE_FLAGS+=(--enable-lto)
CONFIGURE_FLAGS+=(--enable-target-optspace)

# Linker configuration
CONFIGURE_FLAGS+=(--with-linker-hash-style=both)

if [[ "${BOOTSTRAP}" == "true" ]]; then
    # The --with-newlib flag tells GCC to build without assuming a C library is present. This is
    # essential for bootstrap builds where we're building a compiler to *create* the C library itself.
    # Without this flag, GCC's configure scripts would test for libc features (like malloc, stdio, etc.)
    # and fail when they're not found. With --with-newlib:
    # 1. GCC skips all libc feature detection during configure
    # 2. libgcc (compiler runtime) is built with minimal assumptions about libc
    # 3. The resulting compiler can compile freestanding code and libc itself
    # The name is historical - it originally meant "build for newlib", but now means "build without
    # assuming any libc is present", making it suitable for building against any libc (glibc, musl, etc.)
    CONFIGURE_FLAGS+=(--with-newlib)

    # Bootstrap compiler: C only
    CONFIGURE_FLAGS+=(--enable-languages=c)
    CONFIGURE_FLAGS+=(--disable-libstdcxx)

    # Disable GCC's internal 3-stage bootstrap (we're building a bootstrap compiler, not bootstrapping GCC itself)
    CONFIGURE_FLAGS+=(--disable-bootstrap)

    # Disable threading support (not needed for bootstrap compiler)
    CONFIGURE_FLAGS+=(--enable-threads=no)

    # Build static libraries only (no shared libraries)
    CONFIGURE_FLAGS+=(--disable-shared)
else
    # Full compiler: C and C++
    CONFIGURE_FLAGS+=(--enable-languages=c,c++)

    # Disable sanitizers (not needed for basic toolchain)
    CONFIGURE_FLAGS+=(--disable-libsanitizer)

    # Enable POSIX threading
    CONFIGURE_FLAGS+=(--enable-threads=posix)

    # Enable long long integer support
    CONFIGURE_FLAGS+=(--enable-long-long)

    # on gnu: --enable-libmpx
fi

env CC_FOR_BUILD=gcc \
    CFLAGS="-O2 -I${BUILD_TOOLS}/include" \
    CFLAGS_FOR_BUILD="-O2 -I${BUILD_TOOLS}/include" \
    CXXFLAGS="-O2 -I${BUILD_TOOLS}/include" \
    CXXFLAGS_FOR_BUILD="-O2 -I${BUILD_TOOLS}/include" \
    LDFLAGS="-L${BUILD_TOOLS}/lib -static" \
    CFLAGS_FOR_TARGET="-O2" \
    CXXFLAGS_FOR_TARGET="-O2" \
    LDFLAGS_FOR_TARGET="" \
        ${GCC_SOURCE}/configure ${CONFIGURE_FLAGS[@]}


if [[ "${BOOTSTRAP}" == "true" ]]; then
    make -j$(nproc) -l configure-gcc configure-libcpp configure-build-libiberty
    make -j$(nproc) -l all-libcpp all-build-libcpp all-build-libiberty
    make -j$(nproc) -l configure-libdecnumber
    make -j$(nproc) -l -C libdecnumber libdecnumber.a
    make -j$(nproc) -l configure-libbacktrace
    make -j$(nproc) -l -C libbacktrace
    make -j$(nproc) -l -C gcc libgcc.mvars
    make -j$(nproc) -l all-gcc all-target-libgcc
    make install-gcc install-target-libgcc
else
    make -j$(nproc) -l all
    make install
fi


