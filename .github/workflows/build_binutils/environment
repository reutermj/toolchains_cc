#!/bin/bash
set -euox pipefail

# Build parameters from workflow
export BINUTILS_VERSION="${BINUTILS_VERSION}"
export TARGET="${TARGET:-x86_64-linux-gnu}"

# Directory structure
export OUTPUT_DIR="/tmp/output"
export BUILD_TOOLS="/tmp/buildtools"
export ARTIFACTS_DIR="/tmp/artifacts"

# Source directories
export BINUTILS_SOURCE="/tmp/binutils-source"
export ZLIB_SOURCE="/tmp/zlib-source"
export BINUTILS_ARTIFACTS="/tmp/binutils-artifacts"

# Create directory structure
mkdir -p "${OUTPUT_DIR}"
mkdir -p "${BUILD_TOOLS}"
mkdir -p "${ARTIFACTS_DIR}"
mkdir -p "${BINUTILS_SOURCE}"
mkdir -p "${ZLIB_SOURCE}"
mkdir -p "${BINUTILS_ARTIFACTS}"

# Export to GitHub Actions environment if running in CI
if [ -n "${GITHUB_ENV:-}" ]; then
    echo "ARTIFACTS_DIR=${ARTIFACTS_DIR}" >> "${GITHUB_ENV}"
fi

# Retry function with exponential backoff for flaky network operations
# Usage: retry_with_backoff <cleanup_path> <command> [args...]
retry_with_backoff() {
    local cleanup_path="$1"
    shift
    local max_retries=8
    local retry_delay=2

    for attempt in $(seq 1 $max_retries); do
        echo "Attempt ${attempt}/${max_retries}: $@"

        if "$@"; then
            echo "Success: $@"
            return 0
        fi

        # Clean up partial state if path provided
        if [ -n "$cleanup_path" ] && [ -e "$cleanup_path" ]; then
            rm -rf "$cleanup_path"
        fi

        if [ $attempt -lt $max_retries ]; then
            local sleep_time=$((retry_delay ** attempt))
            echo "Failed, retrying in ${sleep_time} seconds..."
            sleep ${sleep_time}
        fi
    done

    echo "Failed after ${max_retries} attempts: $@"
    return 1
}
